# 整数系列

## 整数的内部表达

计算机内部一切都是二进制

一个字节可以表达的数

00000000-11111111(0-255)

三种方案：

1.仿照十进制，有一个特殊的标志表示负数

2.取中间的数为0，如1000000表示0，比它小的是负数，比它大的是正数

3.补码

## 数的范围

对于一个字节（8位），可以表达的是：

00000000-11111111

其中

00000000->0

11111111~10000000-> -1~-128

00000001~01111111-> 1~127

## 整数的范围

char：1字节：-128~127

short：2字节：-32768~32767

int：取决于编译器（CPU），通常的意义是“一个字”

long：4字节

long long：8字节

### unsigned

如果一个字面量常数想要表达自己是unsigned，可以在后面加u或U

255U

用I或L表示long(long)

unsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位

## 整数越界

整数是以纯二进制方式进行计算的，所以：

11111111+1->100000000->0

01111111+1->100000000->-128

10000000-1->01111111->127

## 8进制和16进制

一个以0开始的数字字面量是8进制

一个以0x开始的数字字面量是16进制

%o用于8进制，%x用于16进制

8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关

16进制很适合表达二进制数据，因为4位二进制正好是一个16进制位

8进制的一位数字正好能表达三位二进制

因为早期计算机的字长是12的倍数，而非8

## 选择整数类型

为什么整数要有那么多种？

​	为了准确表达内存，做底层程序的需要

没有特殊需要，就选择int

现在的CPU的字长普遍是32位或64位，一次内存读写就是一个int，一次计算也是一个int，选择更短的类型不会更快，甚至可能更慢

现代的编译器一般会设计内存对齐，所以更短的类型实际在内存中有可能也占据一个int的大小（虽然sizeof告诉你更小）

unsigned与否只是输出的不同，内部计算是一样的